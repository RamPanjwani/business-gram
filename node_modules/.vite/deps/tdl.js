import {
  __commonJS,
  __require
} from "./chunk-7D4SUZUM.js";

// browser-external:node:path
var require_node_path = __commonJS({
  "browser-external:node:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:path" has been externalized for browser compatibility. Cannot access "node:path.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/tdl/dist/util.js
var require_util = __commonJS({
  "node_modules/tdl/dist/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deepRenameKey = exports.mergeDeepRight = void 0;
    function isObject(item) {
      return item != null && typeof item === "object" && !Array.isArray(item);
    }
    function mergeDeepRight(obj1, obj2) {
      if (isObject(obj1) && isObject(obj2)) {
        const result = {};
        for (const key2 in obj2) {
          const val1 = obj1[key2];
          const val2 = obj2[key2];
          result[key2] = mergeDeepRight(val1, val2);
        }
        for (const key1 in obj1) {
          if (!(key1 in result))
            result[key1] = obj1[key1];
        }
        return result;
      }
      return obj2;
    }
    exports.mergeDeepRight = mergeDeepRight;
    function deepRenameKey(oldKey, newKey, v) {
      if (Array.isArray(v))
        return v.map((x) => deepRenameKey(oldKey, newKey, x));
      if (typeof v === "object" && v !== null) {
        const newObj = {};
        for (const k in v)
          newObj[k === oldKey ? newKey : k] = deepRenameKey(oldKey, newKey, v[k]);
        return newObj;
      }
      return v;
    }
    exports.deepRenameKey = deepRenameKey;
  }
});

// browser-external:node:readline
var require_node_readline = __commonJS({
  "browser-external:node:readline"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:readline" has been externalized for browser compatibility. Cannot access "node:readline.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tdl/dist/prompt.js
var require_prompt = __commonJS({
  "node_modules/tdl/dist/prompt.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getName = exports.getPassword = exports.getAuthCode = exports.confirmOnAnotherDevice = exports.getEmailCode = exports.getEmailAddress = exports.getPhoneNumber = void 0;
    var readline = __importStar(require_node_readline());
    function prompt(query) {
      return new Promise((resolve, reject) => {
        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout
        });
        rl.on("SIGINT", () => {
          rl.close();
          reject(new Error("Cancelled"));
        });
        rl.on("error", reject);
        rl.question(query, (answer) => {
          rl.close();
          resolve(answer.replace(/[\r\n]*$/, ""));
        });
      });
    }
    var getPhoneNumber = (retry) => prompt(retry ? "Invalid phone number, please re-enter: " : "Please enter your phone number: ");
    exports.getPhoneNumber = getPhoneNumber;
    var getEmailAddress = () => prompt("Please enter your email address: ");
    exports.getEmailAddress = getEmailAddress;
    var getEmailCode = () => prompt("Please enter the email auth code you received: ");
    exports.getEmailCode = getEmailCode;
    var confirmOnAnotherDevice = (link) => console.log(`Please confirm on another device: ${link}`);
    exports.confirmOnAnotherDevice = confirmOnAnotherDevice;
    var getAuthCode = (retry) => prompt(retry ? "Wrong auth code, please re-enter: " : "Please enter the auth code you received: ");
    exports.getAuthCode = getAuthCode;
    var getPassword = (passwordHint, retry) => {
      const hint = passwordHint ? ` (hint: "${passwordHint}")` : "";
      const query = retry ? `Wrong password, please re-enter${hint}: ` : `Please enter your 2FA password${hint}: `;
      return prompt(query);
    };
    exports.getPassword = getPassword;
    var getName = async () => ({
      firstName: await prompt("Please enter your first name: "),
      lastName: await prompt("Please enter your last name (optional): ") || void 0
    });
    exports.getName = getName;
  }
});

// node_modules/tdl/dist/version.js
var require_version = __commonJS({
  "node_modules/tdl/dist/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Version = void 0;
    var Version = class {
      /** Parse version from a string */
      constructor(ver) {
        const [majorStr, minorStr, patchStr] = ver.split(".");
        const major = Number(majorStr);
        const minor = Number(minorStr);
        const patch = Number(patchStr) || 0;
        if (!majorStr || !minorStr || Number.isNaN(major) || Number.isNaN(minor))
          throw new Error(`Invalid TDLib version '${ver}'`);
        this._major = major;
        this._minor = minor;
        this._patch = patch;
      }
      /** v1.gt(v2) is v1 > v2 */
      gt(other) {
        if (this._major > other._major)
          return true;
        if (this._major < other._major)
          return false;
        if (this._minor > other._minor)
          return true;
        if (this._minor < other._minor)
          return false;
        return this._patch > other._patch;
      }
      /** v1.lt(v2) is v1 < v2 */
      lt(other) {
        if (this._major < other._major)
          return true;
        if (this._major > other._major)
          return false;
        if (this._minor < other._minor)
          return true;
        if (this._minor > other._minor)
          return false;
        return this._patch < other._patch;
      }
      /** v1.gte(v2) is v1 >= v2 */
      gte(other) {
        if (this._major > other._major)
          return true;
        if (this._major < other._major)
          return false;
        if (this._minor > other._minor)
          return true;
        if (this._minor < other._minor)
          return false;
        return this._patch >= other._patch;
      }
      /** v1.lte(v2) is v1 <= v2 */
      lte(other) {
        if (this._major < other._major)
          return true;
        if (this._major > other._major)
          return false;
        if (this._minor < other._minor)
          return true;
        if (this._minor > other._minor)
          return false;
        return this._patch <= other._patch;
      }
      /** v1.eq(v2) is v1 == v2 */
      eq(other) {
        return this._major === other._major && this._minor === other._minor && this._patch === other._patch;
      }
      toString() {
        return `${this._major}.${this._minor}.${this._patch}`;
      }
    };
    exports.Version = Version;
  }
});

// node_modules/tdl/dist/queue.js
var require_queue = __commonJS({
  "node_modules/tdl/dist/queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Queue = void 0;
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0)
          return null;
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    var Queue = class {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
          tail.next = null;
        }
        return next;
      }
    };
    exports.Queue = Queue;
  }
});

// node_modules/tdl/dist/client.js
var require_client = __commonJS({
  "node_modules/tdl/dist/client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Client = exports.UnknownError = exports.TDLibError = void 0;
    var node_path_1 = require_node_path();
    var debug_1 = __importDefault(require_browser());
    var util_1 = require_util();
    var prompt = __importStar(require_prompt());
    var version_1 = require_version();
    var queue_1 = require_queue();
    var debug = (0, debug_1.default)("tdl:client");
    var debugReceive = (0, debug_1.default)("tdl:client:receive");
    var debugReq = (0, debug_1.default)("tdl:client:request");
    var defaultOptions = {
      databaseDirectory: "_td_database",
      filesDirectory: "_td_files",
      databaseEncryptionKey: "",
      useTestDc: false,
      skipOldUpdates: false,
      tdlibParameters: {
        use_message_database: true,
        use_secret_chats: false,
        system_language_code: "en",
        application_version: "1.0",
        device_model: "Unknown device",
        system_version: "Unknown"
      }
    };
    var defaultLoginDetails = {
      type: "user",
      getPhoneNumber: prompt.getPhoneNumber,
      getEmailAddress: prompt.getEmailAddress,
      getEmailCode: prompt.getEmailCode,
      confirmOnAnotherDevice: prompt.confirmOnAnotherDevice,
      getAuthCode: prompt.getAuthCode,
      getPassword: prompt.getPassword,
      getName: prompt.getName
    };
    var TDLibError = class extends Error {
      constructor(code, message) {
        super(message);
        this._ = "error";
        this.code = code;
        this.name = "TDLibError";
      }
      toString() {
        return `TDLibError: ${this.code} ${this.message}`;
      }
    };
    exports.TDLibError = TDLibError;
    var UnknownError = class extends Error {
      constructor(err) {
        if (typeof err === "string")
          super(err);
        else
          super();
        this.err = err;
        this.name = "UnknownError";
      }
    };
    exports.UnknownError = UnknownError;
    var TDLIB_1_8_6 = new version_1.Version("1.8.6");
    var TDLIB_DEFAULT = new version_1.Version("1.8.27");
    var TDL_MAGIC = "-tdl-";
    var Client = class {
      constructor(tdjson, managing, options = {}) {
        var _a, _b;
        this._pending = /* @__PURE__ */ new Map();
        this._requestId = 0;
        this._initialized = false;
        this._preinitRequests = [];
        this._version = TDLIB_DEFAULT;
        this._connectionStateName = "connectionStateWaitingForNetwork";
        this._authorizationState = null;
        this._events = {
          update: /* @__PURE__ */ new Set(),
          error: /* @__PURE__ */ new Set(),
          close: /* @__PURE__ */ new Set()
        };
        this.getVersion = () => {
          if (this._version === TDLIB_DEFAULT)
            throw new Error("Unknown TDLib version");
          return this._version.toString();
        };
        this.on = (event, fn) => {
          let listeners = this._events[event];
          if (listeners == null)
            listeners = this._events[event] = /* @__PURE__ */ new Set();
          listeners.add(fn);
          return this;
        };
        this.once = (event, fn) => {
          let listeners = this._events[event];
          if (listeners == null)
            listeners = this._events[event] = /* @__PURE__ */ new Set();
          fn.once = true;
          listeners.add(fn);
          return this;
        };
        this.off = (event, fn) => {
          const listeners = this._events[event];
          if (listeners == null)
            return false;
          return listeners.delete(fn);
        };
        this.emit = (event, value) => {
          const listeners = this._events[event];
          if (event === "error" && (listeners == null || listeners.size === 0)) {
            Promise.reject(value);
          }
          if (listeners == null)
            return;
          for (const listener of listeners) {
            if (listener.once === true)
              listeners.delete(listener);
            listener(value);
          }
        };
        this.addListener = this.on;
        this.removeListener = this.off;
        this.iterUpdates = () => {
          if (this._client.val == null)
            throw new Error("The client is closed");
          const unconsumedEvents = new queue_1.Queue();
          let defer = null;
          let finished = false;
          const finish = () => {
            this.off("update", onUpdate);
            finished = true;
            debug("Finished an async iterator");
          };
          function onUpdate(update) {
            if (update._ === "updateAuthorizationState" && update.authorization_state._ == "authorizationStateClosed") {
              finish();
            }
            if (defer != null) {
              defer.resolve({ done: false, value: update });
              defer = null;
            } else {
              unconsumedEvents.push(update);
            }
          }
          this.on("update", onUpdate);
          const iterator = {
            next() {
              if (!unconsumedEvents.isEmpty()) {
                const update = unconsumedEvents.shift();
                return Promise.resolve({ done: false, value: update });
              }
              if (finished)
                return Promise.resolve({ done: true, value: void 0 });
              if (defer != null) {
                finish();
                throw new Error("Cannot call next() twice in succession");
              }
              return new Promise((resolve, reject) => {
                defer = { resolve, reject };
              });
            },
            return() {
              finish();
              return Promise.resolve({ done: true, value: void 0 });
            },
            [Symbol.asyncIterator]() {
              return iterator;
            }
          };
          return iterator;
        };
        this.invoke = (request) => {
          const id = this._requestId;
          this._requestId++;
          if (id >= Number.MAX_SAFE_INTEGER)
            throw new Error("Too large request id");
          const responsePromise = new Promise((resolve, reject) => {
            this._pending.set(id, { resolve, reject });
          });
          if (this._initialized === false) {
            this._preinitRequests.push([request, id]);
            return responsePromise;
          }
          this._send(request, id);
          return responsePromise;
        };
        this.close = () => {
          debug("close");
          return new Promise((resolve) => {
            if (this._client.val == null)
              return resolve();
            this._sendTdl({ _: "close" });
            this.once("close", () => resolve());
          });
        };
        this.login = (arg = {}) => {
          return new Promise((resolve, reject) => {
            if (this._client.val == null)
              return reject(new Error("The client is closed"));
            let loginDetails = null;
            function needLoginDetails(l) {
              if (l == null && loginDetails == null) {
                loginDetails = (0, util_1.mergeDeepRight)(defaultLoginDetails, typeof arg === "function" ? arg() : arg);
                l = loginDetails;
              }
              if (l == null)
                throw new Error("Invariant violation: loginDetails is null");
            }
            function needUserLogin(l) {
              if (l == null)
                needLoginDetails(l);
              if (l.type !== "user")
                throw new Error("Expected to log in as a bot, received user auth update");
            }
            const processAuthorizationState = async (authState) => {
              try {
                switch (authState._) {
                  case "authorizationStateReady": {
                    this.off("update", onUpdate);
                    resolve(void 0);
                    return;
                  }
                  case "authorizationStateClosed": {
                    throw new Error("Received authorizationStateClosed");
                  }
                  case "authorizationStateWaitPhoneNumber": {
                    needLoginDetails(loginDetails);
                    let retry = false;
                    if (loginDetails.type === "user") {
                      while (true) {
                        const phoneNumber = await loginDetails.getPhoneNumber(retry);
                        try {
                          await this.invoke({
                            _: "setAuthenticationPhoneNumber",
                            phone_number: phoneNumber
                          });
                          return;
                        } catch (e) {
                          if ((e == null ? void 0 : e.message) === "PHONE_NUMBER_INVALID")
                            retry = true;
                          else
                            throw e;
                        }
                      }
                    } else {
                      while (true) {
                        const token = await loginDetails.getToken(retry);
                        try {
                          await this.invoke({
                            _: "checkAuthenticationBotToken",
                            token
                          });
                          return;
                        } catch (e) {
                          if ((e == null ? void 0 : e.message) === "ACCESS_TOKEN_INVALID")
                            retry = true;
                          else
                            throw e;
                        }
                      }
                    }
                  }
                  case "authorizationStateWaitEmailAddress": {
                    needUserLogin(loginDetails);
                    await this.invoke({
                      _: "setAuthenticationEmailAddress",
                      email_address: await loginDetails.getEmailAddress()
                    });
                    return;
                  }
                  case "authorizationStateWaitEmailCode": {
                    needUserLogin(loginDetails);
                    await this.invoke({
                      _: "checkAuthenticationEmailCode",
                      code: {
                        // Apple ID and Google ID are not supported
                        _: "emailAddressAuthenticationCode",
                        code: await loginDetails.getEmailCode()
                      }
                    });
                    return;
                  }
                  case "authorizationStateWaitOtherDeviceConfirmation": {
                    needUserLogin(loginDetails);
                    loginDetails.confirmOnAnotherDevice(authState.link);
                    return;
                  }
                  case "authorizationStateWaitCode": {
                    needUserLogin(loginDetails);
                    let retry = false;
                    while (true) {
                      const code = await loginDetails.getAuthCode(retry);
                      try {
                        await this.invoke({
                          _: "checkAuthenticationCode",
                          code
                        });
                        return;
                      } catch (e) {
                        if ((e == null ? void 0 : e.message) === "PHONE_CODE_EMPTY" || (e == null ? void 0 : e.message) === "PHONE_CODE_INVALID")
                          retry = true;
                        else
                          throw e;
                      }
                    }
                  }
                  case "authorizationStateWaitRegistration": {
                    needUserLogin(loginDetails);
                    const { firstName, lastName = "" } = await loginDetails.getName();
                    await this.invoke({
                      _: "registerUser",
                      first_name: firstName,
                      last_name: lastName
                    });
                    return;
                  }
                  case "authorizationStateWaitPassword": {
                    needUserLogin(loginDetails);
                    const passwordHint = authState.password_hint;
                    let retry = false;
                    while (true) {
                      const password = await loginDetails.getPassword(passwordHint, retry);
                      try {
                        await this.invoke({
                          _: "checkAuthenticationPassword",
                          password
                        });
                        return;
                      } catch (e) {
                        if ((e == null ? void 0 : e.message) === "PASSWORD_HASH_INVALID")
                          retry = true;
                        else
                          throw e;
                      }
                    }
                  }
                }
              } catch (e) {
                this.off("update", onUpdate);
                reject(e);
              }
            };
            function onUpdate(update) {
              if (update._ !== "updateAuthorizationState")
                return;
              processAuthorizationState(update.authorization_state);
            }
            if (this._authorizationState != null)
              processAuthorizationState(this._authorizationState);
            this.on("update", onUpdate);
          });
        };
        this.loginAsBot = (token) => {
          return this.login({
            type: "bot",
            getToken: (retry) => retry ? Promise.reject(new Error("Invalid bot token")) : Promise.resolve(typeof token === "string" ? token : token())
          });
        };
        this.isClosed = () => {
          return this._client.val == null;
        };
        this._options = (0, util_1.mergeDeepRight)(defaultOptions, options);
        this._tdjson = tdjson;
        this._client = { isTdn: !managing.useOldTdjsonInterface, val: null };
        this.execute = managing.executeFunc;
        if (managing.bare) {
          this._initialized = true;
        } else {
          if (!options.apiId && !((_a = options.tdlibParameters) == null ? void 0 : _a.api_id))
            throw new TypeError("Valid api_id must be provided.");
          if (!options.apiHash && !((_b = options.tdlibParameters) == null ? void 0 : _b.api_hash))
            throw new TypeError("Valid api_hash must be provided.");
        }
        if (options.verbosityLevel != null) {
          throw new TypeError("Set verbosityLevel in tdl.configure instead");
        }
        if (!this._client.isTdn) {
          this._client.val = this._tdjson.tdold.create(managing.receiveTimeout);
          if (this._client.val == null)
            throw new Error("Failed to create a TDLib client");
          this._loop();
        } else {
          this._client.val = this._tdjson.tdnew.createClientId();
          this._sendTdl({ _: "getOption", name: "version" });
        }
      }
      // Called by the client manager in case the new interface is used
      getClientId() {
        if (!this._client.isTdn)
          throw new Error("Cannot get id of a client in the old tdjson interface");
        if (this._client.val == null)
          throw new Error("Cannot get id of a closed client");
        return this._client.val;
      }
      _finishInit() {
        debug("Finished initialization");
        this._initialized = true;
        for (const [request, id] of this._preinitRequests)
          this._send(request, id);
        this._preinitRequests = [];
      }
      // There's a bit of history behind this renaming of @type to _ in tdl.
      // Initially, it was because this code was written in Flow which had a bug
      // with disjoint unions (https://flow.org/en/docs/lang/refinements/)
      // not working if the tag is referenced via square brackets. _ has been chosen
      // because it is already an old convention in JS MTProto libraries and
      // webogram. The bug in Flow was later fixed, however the renaming is kept,
      // since it is more convenient to write  if (o._ === '...')  instead of
      // if (o['@type'] === '...'). Funny, other JS TDLib libraries also followed
      // with this renaming to _.
      _send(request, extra) {
        debugReq("send", request);
        const renamedRequest = (0, util_1.deepRenameKey)("_", "@type", request);
        renamedRequest["@extra"] = extra;
        const tdRequest = JSON.stringify(renamedRequest);
        if (this._client.val == null)
          throw new Error("A closed client cannot be reused, create a new client");
        this._client.isTdn ? this._tdjson.tdnew.send(this._client.val, tdRequest) : this._tdjson.tdold.send(this._client.val, tdRequest);
      }
      _sendTdl(request) {
        this._send(request, TDL_MAGIC);
      }
      _handleClose() {
        if (this._client.val == null) {
          debug("Trying to close an already closed client");
          return;
        }
        if (!this._client.isTdn)
          this._tdjson.tdold.destroy(this._client.val);
        this._client.val = null;
        this.emit("close");
        debug("closed");
      }
      // Used with the old tdjson interface
      async _loop() {
        if (this._client.isTdn)
          throw new Error("Can start the loop in the old tdjson interface only");
        try {
          while (true) {
            if (this._client.val === null) {
              debug("receive loop: destroyed client");
              break;
            }
            const responseString = await this._tdjson.tdold.receive(this._client.val);
            if (responseString == null) {
              debug("receive loop: response is empty");
              continue;
            }
            const res = JSON.parse(responseString);
            this.handleReceive(res);
          }
        } catch (e) {
          this._handleClose();
          throw e;
        }
      }
      // Can be called by the client manager in case the new interface is used
      handleReceive(res) {
        try {
          this._handleReceive((0, util_1.deepRenameKey)("@type", "_", res));
        } catch (e) {
          debug("handleReceive: caught error", e);
          const error = e instanceof Error ? e : new UnknownError(e);
          this.emit("error", error);
        }
      }
      // This function can be called with any TDLib object
      _handleReceive(res) {
        debugReceive(res);
        const isError = res._ === "error";
        const id = res["@extra"];
        const defer = id != null ? this._pending.get(id) : void 0;
        if (defer != null) {
          delete res["@extra"];
          this._pending.delete(id);
          if (isError)
            defer.reject(new TDLibError(res.code, res.message));
          else
            defer.resolve(res);
          return;
        }
        if (isError) {
          const resError = res;
          const error = new TDLibError(resError.code, resError.message);
          if (id != null)
            error["@extra"] = id;
          throw error;
        }
        if (id === TDL_MAGIC) {
          debug("(TDL_MAGIC) Not emitting response", res);
          return;
        }
        this._handleUpdate(res);
      }
      _handleUpdate(update) {
        switch (update._) {
          case "updateOption":
            if (update.name === "version" && update.value._ === "optionValueString") {
              debug("Received version:", update.value.value);
              this._version = new version_1.Version(update.value.value);
            }
            break;
          case "updateConnectionState":
            debug("New connection state:", update.state);
            this._connectionStateName = update.state._;
            break;
          case "updateAuthorizationState":
            debug("New authorization state:", update.authorization_state._);
            this._authorizationState = update.authorization_state;
            if (update.authorization_state._ === "authorizationStateClosed")
              this._handleClose();
            else if (!this._initialized)
              this._handleAuthInit(update.authorization_state);
            break;
          default:
            const shouldSkip = this._options.skipOldUpdates && this._connectionStateName === "connectionStateUpdating";
            if (shouldSkip)
              return;
        }
        this.emit("update", update);
      }
      _handleAuthInit(authState) {
        switch (authState._) {
          case "authorizationStateWaitTdlibParameters":
            if (this._version.lt(TDLIB_1_8_6)) {
              this._sendTdl({
                _: "setTdlibParameters",
                parameters: {
                  database_directory: (0, node_path_1.resolve)(this._options.databaseDirectory),
                  files_directory: (0, node_path_1.resolve)(this._options.filesDirectory),
                  api_id: this._options.apiId,
                  api_hash: this._options.apiHash,
                  use_test_dc: this._options.useTestDc,
                  ...this._options.tdlibParameters,
                  _: "tdlibParameters"
                }
              });
            } else {
              this._sendTdl({
                database_directory: (0, node_path_1.resolve)(this._options.databaseDirectory),
                files_directory: (0, node_path_1.resolve)(this._options.filesDirectory),
                api_id: this._options.apiId,
                api_hash: this._options.apiHash,
                use_test_dc: this._options.useTestDc,
                database_encryption_key: this._options.databaseEncryptionKey,
                ...this._options.tdlibParameters,
                _: "setTdlibParameters"
              });
              this._finishInit();
            }
            return;
          case "authorizationStateWaitEncryptionKey":
            this._sendTdl({
              _: "checkDatabaseEncryptionKey",
              encryption_key: this._options.databaseEncryptionKey
            });
            this._finishInit();
        }
      }
    };
    exports.Client = Client;
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/node-gyp-build/node-gyp-build.js
var require_node_gyp_build = __commonJS({
  "node_modules/node-gyp-build/node-gyp-build.js"(exports, module) {
    var fs = require_fs();
    var path = require_path();
    var os = require_os();
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
    var vars = process.config && process.config.variables || {};
    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    var abi = process.versions.modules;
    var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
    var arch = process.env.npm_config_arch || os.arch();
    var platform = process.env.npm_config_platform || os.platform();
    var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
    var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
    var uv = (process.versions.uv || "").split(".")[0];
    module.exports = load;
    function load(dir) {
      return runtimeRequire(load.resolve(dir));
    }
    load.resolve = load.path = function(dir) {
      dir = path.resolve(dir || ".");
      try {
        var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
        if (process.env[name + "_PREBUILD"]) dir = process.env[name + "_PREBUILD"];
      } catch (err) {
      }
      if (!prebuildsOnly) {
        var release = getFirst(path.join(dir, "build/Release"), matchBuild);
        if (release) return release;
        var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
        if (debug) return debug;
      }
      var prebuild = resolve(dir);
      if (prebuild) return prebuild;
      var nearby = resolve(path.dirname(process.execPath));
      if (nearby) return nearby;
      var target = [
        "platform=" + platform,
        "arch=" + arch,
        "runtime=" + runtime,
        "abi=" + abi,
        "uv=" + uv,
        armv ? "armv=" + armv : "",
        "libc=" + libc,
        "node=" + process.versions.node,
        process.versions.electron ? "electron=" + process.versions.electron : "",
        typeof __webpack_require__ === "function" ? "webpack=true" : ""
        // eslint-disable-line
      ].filter(Boolean).join(" ");
      throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
      function resolve(dir2) {
        var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
        var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
        if (!tuple) return;
        var prebuilds = path.join(dir2, "prebuilds", tuple.name);
        var parsed = readdirSync(prebuilds).map(parseTags);
        var candidates = parsed.filter(matchTags(runtime, abi));
        var winner = candidates.sort(compareTags(runtime))[0];
        if (winner) return path.join(prebuilds, winner.file);
      }
    };
    function readdirSync(dir) {
      try {
        return fs.readdirSync(dir);
      } catch (err) {
        return [];
      }
    }
    function getFirst(dir, filter) {
      var files = readdirSync(dir).filter(filter);
      return files[0] && path.join(dir, files[0]);
    }
    function matchBuild(name) {
      return /\.node$/.test(name);
    }
    function parseTuple(name) {
      var arr = name.split("-");
      if (arr.length !== 2) return;
      var platform2 = arr[0];
      var architectures = arr[1].split("+");
      if (!platform2) return;
      if (!architectures.length) return;
      if (!architectures.every(Boolean)) return;
      return { name, platform: platform2, architectures };
    }
    function matchTuple(platform2, arch2) {
      return function(tuple) {
        if (tuple == null) return false;
        if (tuple.platform !== platform2) return false;
        return tuple.architectures.includes(arch2);
      };
    }
    function compareTuples(a, b) {
      return a.architectures.length - b.architectures.length;
    }
    function parseTags(file) {
      var arr = file.split(".");
      var extension = arr.pop();
      var tags = { file, specificity: 0 };
      if (extension !== "node") return;
      for (var i = 0; i < arr.length; i++) {
        var tag = arr[i];
        if (tag === "node" || tag === "electron" || tag === "node-webkit") {
          tags.runtime = tag;
        } else if (tag === "napi") {
          tags.napi = true;
        } else if (tag.slice(0, 3) === "abi") {
          tags.abi = tag.slice(3);
        } else if (tag.slice(0, 2) === "uv") {
          tags.uv = tag.slice(2);
        } else if (tag.slice(0, 4) === "armv") {
          tags.armv = tag.slice(4);
        } else if (tag === "glibc" || tag === "musl") {
          tags.libc = tag;
        } else {
          continue;
        }
        tags.specificity++;
      }
      return tags;
    }
    function matchTags(runtime2, abi2) {
      return function(tags) {
        if (tags == null) return false;
        if (tags.runtime && tags.runtime !== runtime2 && !runtimeAgnostic(tags)) return false;
        if (tags.abi && tags.abi !== abi2 && !tags.napi) return false;
        if (tags.uv && tags.uv !== uv) return false;
        if (tags.armv && tags.armv !== armv) return false;
        if (tags.libc && tags.libc !== libc) return false;
        return true;
      };
    }
    function runtimeAgnostic(tags) {
      return tags.runtime === "node" && tags.napi;
    }
    function compareTags(runtime2) {
      return function(a, b) {
        if (a.runtime !== b.runtime) {
          return a.runtime === runtime2 ? -1 : 1;
        } else if (a.abi !== b.abi) {
          return a.abi ? -1 : 1;
        } else if (a.specificity !== b.specificity) {
          return a.specificity > b.specificity ? -1 : 1;
        } else {
          return 0;
        }
      };
    }
    function isNwjs() {
      return !!(process.versions && process.versions.nw);
    }
    function isElectron() {
      if (process.versions && process.versions.electron) return true;
      if (process.env.ELECTRON_RUN_AS_NODE) return true;
      return typeof window !== "undefined" && window.process && window.process.type === "renderer";
    }
    function isAlpine(platform2) {
      return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
    }
    load.parseTags = parseTags;
    load.matchTags = matchTags;
    load.compareTags = compareTags;
    load.parseTuple = parseTuple;
    load.matchTuple = matchTuple;
    load.compareTuples = compareTuples;
  }
});

// node_modules/node-gyp-build/index.js
var require_node_gyp_build2 = __commonJS({
  "node_modules/node-gyp-build/index.js"(exports, module) {
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
    if (typeof runtimeRequire.addon === "function") {
      module.exports = runtimeRequire.addon.bind(runtimeRequire);
    } else {
      module.exports = require_node_gyp_build();
    }
  }
});

// node_modules/tdl/dist/addon.js
var require_addon = __commonJS({
  "node_modules/tdl/dist/addon.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadAddon = void 0;
    var path = __importStar(require_node_path());
    var node_gyp_build_1 = __importDefault(require_node_gyp_build2());
    var packageDir = path.join(__dirname, "..");
    function loadAddon(libraryFile, ignoreAlreadyLoaded = false) {
      const addon = (0, node_gyp_build_1.default)(packageDir);
      const success = addon.loadTdjson(libraryFile);
      if (!success && !ignoreAlreadyLoaded)
        throw new Error("tdjson is already loaded");
      return {
        tdold: {
          create: addon.tdoCreate,
          send: addon.tdoSend,
          receive: addon.tdoReceive,
          execute: addon.tdoExecute,
          destroy: addon.tdoDestroy
        },
        tdnew: {
          init: addon.tdnInit,
          ref: addon.tdnRef,
          unref: addon.tdnUnref,
          createClientId: addon.tdnCreateClientId,
          send: addon.tdnSend,
          receive: addon.tdnReceive,
          execute: addon.tdnExecute
        },
        setLogMessageCallback: addon.setLogMessageCallback
      };
    }
    exports.loadAddon = loadAddon;
  }
});

// node_modules/tdl/dist/index.js
var require_dist = __commonJS({
  "node_modules/tdl/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownError = exports.TDLibError = exports.createBareClient = exports.createClient = exports.setLogMessageCallback = exports.execute = exports.init = exports.configure = void 0;
    var path = __importStar(require_node_path());
    var debug_1 = __importDefault(require_browser());
    var client_1 = require_client();
    Object.defineProperty(exports, "TDLibError", { enumerable: true, get: function() {
      return client_1.TDLibError;
    } });
    Object.defineProperty(exports, "UnknownError", { enumerable: true, get: function() {
      return client_1.UnknownError;
    } });
    var addon_1 = require_addon();
    var util_1 = require_util();
    var debug = (0, debug_1.default)("tdl");
    var tdjsonAddon = null;
    var defaultLibraryFile = (() => {
      switch (process.platform) {
        case "win32":
          return "tdjson.dll";
        case "darwin":
          return "libtdjson.dylib";
        default:
          return "libtdjson.so";
      }
    })();
    var cfg = {
      tdjson: defaultLibraryFile,
      libdir: "",
      verbosityLevel: 1,
      receiveTimeout: 10,
      useOldTdjsonInterface: false
    };
    function configure(opts = {}) {
      if (tdjsonAddon)
        throw Error("TDLib is already initialized; too late to configure");
      if (opts.tdjson != null)
        cfg.tdjson = opts.tdjson;
      if (opts.libdir != null)
        cfg.libdir = opts.libdir;
      if (opts.verbosityLevel != null)
        cfg.verbosityLevel = opts.verbosityLevel;
      if (opts.receiveTimeout != null)
        cfg.receiveTimeout = opts.receiveTimeout;
      if (opts.useOldTdjsonInterface != null)
        cfg.useOldTdjsonInterface = opts.useOldTdjsonInterface;
    }
    exports.configure = configure;
    function init() {
      if (tdjsonAddon != null)
        return;
      debug("Initializing the node addon");
      const lib = path.join(cfg.libdir, cfg.tdjson);
      tdjsonAddon = (0, addon_1.loadAddon)(lib, cfg.useOldTdjsonInterface);
      if (cfg.verbosityLevel !== "default") {
        debug("Executing setLogVerbosityLevel", cfg.verbosityLevel);
        const request = JSON.stringify({
          "@type": "setLogVerbosityLevel",
          new_verbosity_level: cfg.verbosityLevel
        });
        const response = !cfg.useOldTdjsonInterface ? tdjsonAddon.tdnew.execute(request) : tdjsonAddon.tdold.execute(null, request);
        debug("setLogVerbosityLevel response:", response);
      }
    }
    exports.init = init;
    var execute = function execute2(request) {
      if (tdjsonAddon == null) {
        init();
        if (tdjsonAddon == null)
          throw Error("TDLib is uninitialized");
      }
      debug("execute", request);
      request = JSON.stringify((0, util_1.deepRenameKey)("_", "@type", request));
      const response = !cfg.useOldTdjsonInterface ? tdjsonAddon.tdnew.execute(request) : tdjsonAddon.tdold.execute(null, request);
      return (0, util_1.deepRenameKey)("@type", "_", JSON.parse(response));
    };
    exports.execute = execute;
    function setLogMessageCallback(maxVerbosityLevel, callback) {
      if (tdjsonAddon == null) {
        init();
        if (tdjsonAddon == null)
          throw Error("TDLib is uninitialized");
      }
      tdjsonAddon.setLogMessageCallback(maxVerbosityLevel, callback);
    }
    exports.setLogMessageCallback = setLogMessageCallback;
    var clientMap = /* @__PURE__ */ new Map();
    var tdnInitialized = false;
    var runningReceiveLoop = false;
    async function receiveLoop() {
      debug("Starting tdn receive loop");
      if (tdjsonAddon == null)
        throw new Error("TDLib is uninitialized");
      runningReceiveLoop = true;
      try {
        tdjsonAddon.tdnew.ref();
        while (true) {
          if (clientMap.size < 1) {
            debug("Stopping receive loop");
            break;
          }
          const responseString = await tdjsonAddon.tdnew.receive();
          if (responseString == null) {
            debug("Receive loop: got empty response");
            continue;
          }
          const res = JSON.parse(responseString);
          const clientId = res["@client_id"];
          const client = clientId != null ? clientMap.get(clientId) : void 0;
          if (client == null) {
            debug(`Cannot find client_id ${clientId}`);
            continue;
          }
          delete res["@client_id"];
          client.handleReceive(res);
        }
      } finally {
        runningReceiveLoop = false;
        tdjsonAddon.tdnew.unref();
      }
    }
    function createAnyClient(opts, bare = false) {
      if (tdjsonAddon == null) {
        init();
        if (tdjsonAddon == null)
          throw Error("TDLib is uninitialized");
      }
      const managingOpts = {
        bare,
        receiveTimeout: cfg.receiveTimeout,
        executeFunc: exports.execute,
        useOldTdjsonInterface: false
      };
      if (cfg.useOldTdjsonInterface) {
        const tdoManaging = { ...managingOpts, useOldTdjsonInterface: true };
        return new client_1.Client(tdjsonAddon, tdoManaging, opts);
      }
      if (!tdnInitialized) {
        tdjsonAddon.tdnew.init(cfg.receiveTimeout);
        tdnInitialized = true;
      }
      const client = new client_1.Client(tdjsonAddon, managingOpts, opts);
      const clientId = client.getClientId();
      clientMap.set(clientId, client);
      client.once("close", () => {
        debug(`Deleting client_id ${clientId}`);
        clientMap.delete(clientId);
      });
      if (!runningReceiveLoop)
        receiveLoop();
      return client;
    }
    function createClient(opts) {
      return createAnyClient(opts);
    }
    exports.createClient = createClient;
    function createBareClient() {
      return createAnyClient({}, true);
    }
    exports.createBareClient = createBareClient;
  }
});
export default require_dist();
//# sourceMappingURL=tdl.js.map
